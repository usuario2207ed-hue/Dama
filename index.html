<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>‚ôüÔ∏èDamas</title>
<style>
  :root{
    --bg:#0f1115;
    --panel:#171a21;
    --text:#e6e8ee;
    --muted:#9aa3b2;
    --accent:#4f8cff;
    --board-dark:#3b475a;
    --board-light:#c7d0dd;
    --red:#e55858;
    --black:#2f3747;
    --king:#ffd34d;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    min-height:100dvh;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans";
    background: radial-gradient(1200px 800px at 50% -10%, #1b2130 0%, var(--bg) 60%);
    color:var(--text);
    display:flex;
    align-items:center;
    justify-content:center;
    padding:16px;
  }
  .wrap{
    width:min(92vmin, 720px);
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:12px;
  }
  .card{
    width:100%;
    background:var(--panel);
    border:1px solid #242a36;
    border-radius:18px;
    box-shadow: 0 10px 30px rgba(0,0,0,.35);
    padding:14px;
  }
  .row{ display:flex; gap:12px; align-items:center; justify-content:space-between; flex-wrap:wrap; }
  h1{ font-size:clamp(18px, 2.8vmin, 28px); margin:0 0 8px 0; letter-spacing:.5px; }
  .controls{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
  select, button{
    background:#10131a; border:1px solid #2a3242; color:var(--text);
    padding:10px 12px; border-radius:12px; font-size:15px; cursor:pointer; outline:none;
  }
  select:focus, button:focus{ border-color:var(--accent) }
  button.primary{ background:linear-gradient(180deg, #2d68ff, #1a48cf); border-color:#1a48cf }
  button:disabled{ opacity:.6; cursor:not-allowed }
  .status{ color:var(--muted); font-size:14px; min-width:240px; }
  .board-wrap{ width:100%; aspect-ratio:1/1; display:grid; place-items:center; }
  canvas{ width:100% !important; height:100% !important; max-width:100%; border-radius:14px; background:#0000; touch-action:none; outline:none; }
  .legend{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; color:var(--muted); font-size:13px; margin-top:4px; }
  .dot{ width:12px; height:12px; border-radius:50%; display:inline-block; margin-right:6px; vertical-align:middle }
  .dot.red{ background:var(--red) } .dot.black{ background:var(--black) }
  .hint{ color:#9bd1ff }
  .you{ font-weight:700; color:var(--text); margin-left:6px; font-size:12px; }
  footer{ position:fixed; left:0; right:0; bottom:8px; text-align:center; font:12px/1.4 system-ui; color:#9aa3b2; pointer-events:none; }
  canvas:focus { box-shadow: 0 0 0 3px rgba(79,140,255,0.12); border-radius:12px; }
</style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="row">
        <h1>‚ôüÔ∏èDamas ‚Äì üë®Jogador vs ü§ñRoboCell</h1>
        <div class="controls">
          <label>
            <span style="margin-right:6px;">Dificuldade</span>
            <select id="difficulty">
              <option value="EASY">F√°cil</option>
              <option value="MEDIUM" selected>M√©dio</option>
              <option value="HARD">Avan√ßado</option>
            </select>
          </label>
          <label>
            <span style="margin-right:6px;">Voc√™ joga com</span>
            <select id="humanColor">
              <option value="BLACK" selected>Preto (come√ßa)</option>
              <option value="RED">Vermelho</option>
            </select>
          </label>
          <button id="newGame" class="primary">Novo Jogo</button>
        </div>
      </div>
      <div class="row" style="margin-top:6px;">
        <div class="status" id="status">Sua vez. Toque/Clique para mover.</div>
      </div>
    </div>

    <div class="board-wrap card">
      <canvas id="board" width="800" height="800" aria-label="Tabuleiro de Damas" tabindex="0"></canvas>
      <div class="legend" id="legend">
        <span id="legend-black"><i class="dot black"></i>Preto <span class="you">(Voc√™)</span></span>
        <span id="legend-red"><i class="dot red"></i>Vermelho</span>
        <span class="hint">‚Ä¢ Capturas s√£o obrigat√≥rias ‚Ä¢ Toque na pe√ßa e depois no destino</span>
      </div>
    </div>
  </div>

  <footer>üéÆDesenvolvido por <strong>EDCELLTECH</strong></footer>

<script>
/* ===========================
   Damas ‚Äì Reescrito (com som + anima√ß√£o)
   =========================== */

const SIZE = 8;
const DARK = 1;   // preto
const RED  = -1;  // vermelho
const EMPTY = 0;
const MAN = 1;
const KING = 2;

const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
const statusEl = document.getElementById('status');
const selDifficulty = document.getElementById('difficulty');
const selHumanColor = document.getElementById('humanColor');
const btnNew = document.getElementById('newGame');
const legendBlack = document.getElementById('legend-black');
const legendRed = document.getElementById('legend-red');

let cell, board, turn, humanColor = DARK, aiColor = RED;
let selected = null;
let legalMoves = [];
let hints = [];
let isThinking = false;
let aiRunId = 0;
let movesWithoutCapture = 0;
const MOVES_WITHOUT_CAPTURE_LIMIT = 40;

let audioContext = null; // criado lazy
function ensureAudio(){
  if(!audioContext){
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
  }
}

/* ---------- SONS (WebAudio) ---------- */
/* sons gerados programaticamente; voc√™ pode ajustar volumes/parametros aqui */
function playSound(kind){
  try{
    ensureAudio();
    const t = audioContext.currentTime;
    const gain = audioContext.createGain();
    gain.connect(audioContext.destination);
    // ajuste volumes por tipo
    switch(kind){
      case 'move':
        gain.gain.value = 0.08;
        {
          const o = audioContext.createOscillator();
          o.type = 'sine';
          o.frequency.setValueAtTime(700, t);
          o.frequency.exponentialRampToValueAtTime(900, t+0.06);
          o.connect(gain);
          o.start(t);
          o.stop(t+0.09);
        }
        break;
      case 'capture':
        gain.gain.value = 0.12;
        {
          const o = audioContext.createOscillator();
          o.type = 'triangle';
          o.frequency.setValueAtTime(350, t);
          o.frequency.exponentialRampToValueAtTime(600, t+0.05);
          o.connect(gain);
          o.start(t);
          o.stop(t+0.12);
        }
        break;
      case 'king':
        gain.gain.value = 0.14;
        {
          // camadas para soar mais "triunfante"
          const o1 = audioContext.createOscillator();
          o1.type='sine'; o1.frequency.setValueAtTime(700, t);
          const o2 = audioContext.createOscillator();
          o2.type='sine'; o2.frequency.setValueAtTime(1000, t);
          const g2 = audioContext.createGain(); g2.gain.value = 0.6;
          o1.connect(gain); o2.connect(g2); g2.connect(gain);
          o1.start(t); o2.start(t);
          o1.stop(t+0.25); o2.stop(t+0.25);
        }
        break;
      case 'win':
        gain.gain.value = 0.14;
        {
          // sequ√™ncia curta ascendentes
          const freqs = [440, 550, 660];
          freqs.forEach((f,i)=>{
            const o = audioContext.createOscillator();
            o.type='sine';
            o.frequency.setValueAtTime(f, t + i*0.08);
            o.connect(gain);
            o.start(t + i*0.08);
            o.stop(t + i*0.08 + 0.12);
          });
        }
        break;
      case 'lose':
        gain.gain.value = 0.12;
        {
          // dois tons descendentes
          const o = audioContext.createOscillator();
          o.type='sawtooth';
          o.frequency.setValueAtTime(300, t);
          o.connect(gain);
          o.start(t);
          o.frequency.exponentialRampToValueAtTime(180, t+0.35);
          o.stop(t+0.4);
        }
        break;
      default:
        break;
    }
  }catch(err){
    // se √°udio falhar, n√£o quebra o jogo
    console.warn('audio fail', err);
  }
}

/* ---------- Util ---------- */
const within = (r,c) => r>=0 && r<SIZE && c>=0 && c<SIZE;
function cloneBoard(b){
  try{ return typeof structuredClone === 'function' ? structuredClone(b) : JSON.parse(JSON.stringify(b)); }
  catch(e){ return JSON.parse(JSON.stringify(b)); }
}
function pieceAt(b, r,c){ return b[r][c]; }
function setPiece(b, r,c, v){ b[r][c] = v; }
function isEmpty(p){ return p===EMPTY; }
function isSide(p, side){ return p!==EMPTY && p.side===side; }
function isKing(p){ return p!==EMPTY && p.kind===KING; }

const DIRS = {
  [DARK]: [[-1,-1],[-1,1]],
  [RED]:  [[1,-1],[1,1]],
  KING:   [[-1,-1],[-1,1],[1,-1],[1,1]]
};

/* ---------- Inicializa√ß√£o ---------- */
function newBoard(){
  const b = Array.from({length:SIZE}, ()=>Array.from({length:SIZE}, ()=>EMPTY));
  for(let r=0;r<3;r++){
    for(let c=0;c<SIZE;c++){
      if((r+c)%2===1) b[r][c] = {side: RED, kind: MAN};
    }
  }
  for(let r=SIZE-3;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      if((r+c)%2===1) b[r][c] = {side: DARK, kind: MAN};
    }
  }
  return b;
}

/* ---------- Desenho ---------- */
function draw(){
  const pad = 12;
  const w = canvas.width, h = canvas.height;
  cell = Math.floor((Math.min(w,h) - pad*2)/SIZE);
  const ox = Math.floor((w - cell*SIZE)/2);
  const oy = Math.floor((h - cell*SIZE)/2);
  ctx.clearRect(0,0,w,h);
  ctx.save();
  // quadrados
  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      const x = ox + c*cell, y = oy + r*cell;
      const dark = (r+c)%2===1;
      ctx.fillStyle = dark ? getVar('--board-dark') : getVar('--board-light');
      ctx.fillRect(x,y,cell,cell);
    }
  }

  // sele√ß√£o e dicas
  if(selected){
    const [sr, sc] = selected;
    drawRoundedRect(ox+sc*cell, oy+sr*cell, cell, cell, 10, 'rgba(79,140,255,.08)', 3, getVar('--accent'));
    const moves = legalMoves.filter(m => m.from[0]===sr && m.from[1]===sc);
    moves.forEach(m=>{
      const [tr, tc] = m.path[m.path.length-1];
      drawCircle(ox+tc*cell+cell/2, oy+tr*cell+cell/2, cell*0.14, 'rgba(155,209,255,.85)');
    });
  }
  hints.forEach(([r,c])=> drawCircle(ox+c*cell+cell/2, oy+r*cell+cell/2, cell*0.12, 'rgba(255,211,77,.85)'));

  // pe√ßas (poderemos desenhar pe√ßa m√≥vel separadamente se houver anima√ß√£o)
  const disp = displayBoard || board;
  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      const p = disp[r][c];
      if(isEmpty(p)) continue;
      const x = ox + c*cell + cell/2;
      const y = oy + r*cell + cell/2;
      const color = p.side===DARK ? getVar('--black') : getVar('--red');
      drawPiece(x,y,cell*0.38, color, 'rgba(0,0,0,0.55)');
      if(p.kind===KING) drawCrown(x, y, cell*0.18);
    }
  }

  // se animando pe√ßa, ela ser√° desenhada por animate loop
  ctx.restore();
}

function getVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
function drawRoundedRect(x,y,w,h,r, fill, strokeW=0, stroke=null){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
  if(fill){ ctx.fillStyle=fill; ctx.fill(); }
  if(stroke && strokeW){ ctx.lineWidth=strokeW; ctx.strokeStyle=stroke; ctx.stroke(); }
}
function drawCircle(x,y,rad,fill){ ctx.beginPath(); ctx.arc(x,y,rad,0,Math.PI*2); ctx.closePath(); ctx.fillStyle=fill; ctx.fill(); }

function drawPiece(x,y,r,fill,shadow){
  ctx.save();
  ctx.shadowColor = shadow; ctx.shadowBlur = 12; ctx.shadowOffsetY = 3;
  ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.closePath();
  ctx.fillStyle = fill; ctx.fill();
  ctx.restore();

  ctx.lineWidth = Math.max(2, r*0.12);
  ctx.strokeStyle = 'rgba(0,0,0,0.45)';
  ctx.beginPath(); ctx.arc(x,y,r*0.92,0,Math.PI*2); ctx.stroke();

  ctx.lineWidth = Math.max(1, r*0.06);
  ctx.strokeStyle = 'rgba(255,255,255,0.92)';
  ctx.beginPath(); ctx.arc(x,y,r*0.86,0,Math.PI*2); ctx.stroke();
}

function drawCrown(x,y,r){
  ctx.save(); ctx.fillStyle = getVar('--king');
  ctx.beginPath();
  ctx.moveTo(x-r, y+r*0.6);
  ctx.lineTo(x-r*0.6, y-r*0.2);
  ctx.lineTo(x, y+r*0.2);
  ctx.lineTo(x+r*0.6, y-r*0.2);
  ctx.lineTo(x+r, y+r*0.6);
  ctx.closePath(); ctx.fill(); ctx.restore();
}

/* ---------- Regras e movimentos (mesmo que antes) ---------- */
function getAllMoves(b, side){
  const captures = [], noncaptures = [];
  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      if(!isSide(b[r][c], side)) continue;
      const pieceMoves = getMovesForPiece(b, r,c);
      pieceMoves.forEach(m => (m.isCapture ? captures : noncaptures).push(m));
    }
  }
  if(captures.length) return pruneMultiJumpContinuations(b, captures, side);
  return noncaptures;
}

function getMovesForPiece(b, r,c){
  const p = b[r][c];
  if(isEmpty(p)) return [];
  const moves = [];
  const dirs = p.kind===KING ? DIRS.KING : DIRS[p.side];

  // Capturas diretas
  dirs.forEach(([dr,dc])=>{
    const mr = r+dr, mc = c+dc;
    const tr = r+2*dr, tc = c+2*dc;
    if(within(tr,tc) && within(mr,mc)){
      const mid = b[mr][mc];
      if(!isEmpty(mid) && mid.side!==p.side && isEmpty(b[tr][tc])){
        moves.push({ from:[r,c], path:[[tr,tc]], captures:[[mr,mc]], isCapture:true });
      }
    }
  });

  // Movimentos simples (somente se n√£o houver captura poss√≠vel)
  if(!moves.length){
    dirs.forEach(([dr,dc])=>{
      const tr = r+dr, tc = c+dc;
      if(within(tr,tc) && isEmpty(b[tr][tc])){
        moves.push({ from:[r,c], path:[[tr,tc]], captures:[], isCapture:false });
      }
    });
  }
  return moves;
}

function pruneMultiJumpContinuations(b, capMoves, side){
  const expanded = [];
  for(const m of capMoves){ expand(b, m, expanded); }
  return expanded.filter(mm => !canContinueCapture(applyMove(cloneBoard(b), mm, true), mm));
}

function expand(b, move, out){
  const bb = applyMove(cloneBoard(b), move, true);
  const last = move.path[move.path.length-1];
  const [r,c] = last;
  const p = bb[r][c];
  const dirs = p.kind===KING ? DIRS.KING : DIRS[p.side];
  let extended = false;

  for(const [dr,dc] of dirs){
    const mr=r+dr, mc=c+dc, tr=r+2*dr, tc=c+2*dc;
    if(!within(tr,tc) || !within(mr,mc)) continue;
    if(!isEmpty(bb[mr][mc]) && bb[mr][mc].side!==p.side && isEmpty(bb[tr][tc])){
      extended = true;
      const next = {
        from: move.from.slice(),
        path: move.path.concat([[tr,tc]]),
        captures: move.captures.concat([[mr,mc]]),
        isCapture:true
      };
      expand(b, next, out);
    }
  }
  if(!extended) out.push(move);
}

function canContinueCapture(b, move){
  const last = move.path[move.path.length-1];
  const [r,c]=last;
  const p = b[r][c];
  if(isEmpty(p)) return false;
  const dirs = p.kind===KING ? DIRS.KING : DIRS[p.side];
  for(const [dr,dc] of dirs){
    const mr=r+dr, mc=c+dc, tr=r+2*dr, tc=c+2*dc;
    if(within(tr,tc) && within(mr,mc) && !isEmpty(b[mr][mc]) && b[mr][mc].side!==p.side && isEmpty(b[tr][tc])){
      return true;
    }
  }
  return false;
}

function applyMove(b, move, mut=false){
  const bb = mut ? b : cloneBoard(b);
  const [fr,fc] = move.from;
  const [tr,tc] = move.path[move.path.length-1];
  const p = bb[fr][fc];
  bb[fr][fc] = EMPTY;
  bb[tr][tc] = p;

  for(const [cr,cc] of move.captures){ bb[cr][cc] = EMPTY; }

  if(p && p.kind===MAN){
    if(p.side===DARK && tr===0) bb[tr][tc] = {side:p.side, kind:KING};
    if(p.side===RED  && tr===SIZE-1) bb[tr][tc] = {side:p.side, kind:KING};
  }
  return bb;
}

function hasAnyMove(b, side){ return getAllMoves(b, side).length>0; }
function countPieces(b){
  let d=0, r=0, dk=0, rk=0;
  for(let i=0;i<SIZE;i++) for(let j=0;j<SIZE;j++){
    const p=b[i][j]; if(isEmpty(p)) continue;
    if(p.side===DARK){ if(p.kind===KING) dk++; else d++; }
    if(p.side===RED ){ if(p.kind===KING) rk++; else r++; }
  }
  return {d,dk,r,rk};
}

/* ---------- IA (minimax com alpha-beta) ---------- */
function evaluate(b, side){
  const {d,dk,r,rk} = countPieces(b);
  const material = (d + 1.6*dk) - (r + 1.6*rk);
  const mobility = (getAllMoves(b, DARK).length - getAllMoves(b, RED).length) * 0.05;
  let prog = 0;
  for(let r0=0;r0<SIZE;r0++) for(let c0=0;c0<SIZE;c0++){
    const p=b[r0][c0]; if(isEmpty(p) || p.kind===KING) continue;
    if(p.side===DARK) prog += (SIZE-1 - r0) * 0.01;
    else prog -= (r0) * 0.01;
  }
  const scoreFromBlack = material + mobility + prog;
  return side===DARK ? scoreFromBlack : -scoreFromBlack;
}

function orderMoves(moves){
  return moves.sort((a,b)=>{
    if(a.isCapture !== b.isCapture) return b.isCapture - a.isCapture;
    const aEnd = a.path[a.path.length-1];
    const bEnd = b.path[b.path.length-1];
    const ac = centerScore(aEnd[0], aEnd[1]);
    const bc = centerScore(bEnd[0], bEnd[1]);
    return bc - ac;
  });
}

function minimax(b, depth, alpha, beta, side, maxSide, startTime, timeLimitMs){
  if(depth===0 || !hasAnyMove(b, side)) return {score: evaluate(b, maxSide), move:null};
  if(Date.now() - startTime > timeLimitMs) return {score: evaluate(b, maxSide), move:null};

  let moves = getAllMoves(b, side);
  if(!moves.length) return {score: evaluate(b, maxSide), move:null};
  moves = orderMoves(moves);

  if(side===maxSide){
    let best = -Infinity, bestMove = null;
    for(const m of moves){
      const bb = applyMove(b, m);
      const val = minimax(bb, depth-1, alpha, beta, -side, maxSide, startTime, timeLimitMs).score;
      if(val>best){ best=val; bestMove=m; }
      alpha = Math.max(alpha, val);
      if(beta<=alpha) break;
    }
    return {score:best, move:bestMove};
  }else{
    let best = Infinity, bestMove = null;
    for(const m of moves){
      const bb = applyMove(b, m);
      const val = minimax(bb, depth-1, alpha, beta, -side, maxSide, startTime, timeLimitMs).score;
      if(val<best){ best=val; bestMove=m; }
      beta = Math.min(beta, val);
      if(beta<=alpha) break;
    }
    return {score:best, move:bestMove};
  }
}

function centerScore(r,c){
  const cr = Math.abs((SIZE-1)/2 - r);
  const cc = Math.abs((SIZE-1)/2 - c);
  return - (cr+cc);
}

function getLimits(level){
  switch(level){
    case 'EASY': return {depth: 2, timeMs: 250};
    case 'MEDIUM': return {depth: 4, timeMs: 700};
    case 'HARD': return {depth: 6, timeMs: 1400};
    default: return {depth:4, timeMs:700};
  }
}

/* ---------- IA flow ---------- */
function aiThinkAndMove(){
  const myRun = ++aiRunId;
  if(isThinking) return;
  isThinking = true;
  setControlsEnabled(false);
  setStatus("Computador pensando‚Ä¶");
  requestAnimationFrame(()=> setTimeout(()=> {
    if(myRun !== aiRunId){ isThinking=false; setControlsEnabled(true); return; }

    const allMoves = getAllMoves(board, aiColor);
    if(!allMoves.length){
      setStatus("‚úÖ Voc√™ venceu!");
      playSound('win');
      isThinking=false; setControlsEnabled(true); draw();
      return;
    }

    const {depth, timeMs} = getLimits(selDifficulty.value);
    const res = minimax(board, depth, -Infinity, Infinity, aiColor, aiColor, Date.now(), timeMs);
    let move = res.move;
    if(!move){
      const all = getAllMoves(board, aiColor);
      move = all[Math.floor(Math.random()*all.length)] || null;
    }

    if(myRun !== aiRunId){ isThinking=false; setControlsEnabled(true); return; }
    if(move) animateAndApplyMove(move, false);
    else { setStatus("‚úÖ Voc√™ venceu!"); playSound('win'); }

    isThinking = false;
    setControlsEnabled(true);
  }, 10));
}

/* ---------- Fluxo de jogo (start/compute/play) ---------- */
function startGame(){
  aiRunId++;
  isThinking = false;
  setControlsEnabled(true);
  movesWithoutCapture = 0;

  board = newBoard();
  selected = null;
  hints = [];
  turn = DARK;
  humanColor = (selHumanColor.value==='BLACK') ? DARK : RED;
  aiColor = -humanColor;
  updateLegend();
  computeLegal();
  draw();
  if(turn===aiColor) aiThinkAndMove();
  else setStatus("Sua vez. Selecione uma pe√ßa.");
}

function computeLegal(){
  legalMoves = getAllMoves(board, turn);
  hints = [];
  if(legalMoves.some(m=>m.isCapture)){
    const set = new Set(legalMoves.map(m=>m.from.toString()));
    for(const key of set){
      const [r,c] = key.split(',').map(Number);
      hints.push([r,c]);
    }
  }
}

/* ---------- Anima√ß√£o + aplica√ß√£o segura do movimento ---------- */
/*
  Estrat√©gia:
  - Criar displayBoard = clone(board) e remover pe√ßa fonte
  - Animate each segment of move.path step-by-step (ler path array)
  - Ao chegar em step, remover a pe√ßa capturada correspondente (se houver)
  - Tocar sons: 'move' no in√≠cio do segmento, 'capture' ao capturar, 'king' se promo√ß√£o
  - Ao final, aplicar o move logicamente (applyMove) e continuar o fluxo normal
*/
let displayBoard = null;
let animating = false;

async function animateAndApplyMove(move, fromHuman){
  if(animating) return;
  animating = true;

  // preparar displayBoard (cloned board for anim)
  displayBoard = cloneBoard(board);

  const [fr,fc] = move.from;
  const p = cloneBoard(board)[fr][fc];
  // remove pe√ßa da origem no display (ser√° desenhada em movimento)
  displayBoard[fr][fc] = EMPTY;

  // array de pontos de path completa (inclui origem para facilitar)
  const steps = [ [fr,fc], ...move.path.map(x=>x.slice()) ];

  // Para cada segmento (i -> i+1) animar
  for(let i=0;i<steps.length-1;i++){
    const from = steps[i], to = steps[i+1];
    await animateSegment(from, to, p, move, i);
    // se esse segmento tinha captura, remover a pe√ßa capturada na displayBoard
    if(move.captures && move.captures[i]){
      const [cr,cc] = move.captures[i];
      displayBoard[cr][cc] = EMPTY;
      playSound('capture');
    }
  }

  // Ao final do movimento, aplicar o move logicamente no board
  const hadCapture = move.captures && move.captures.length>0;
  if(hadCapture) movesWithoutCapture = 0; else movesWithoutCapture++;

  board = applyMove(board, move, true);

  // ver se houve promo√ß√£o no destino
  const dest = move.path[move.path.length-1];
  const finalPiece = board[dest[0]][dest[1]];
  if(finalPiece && finalPiece.kind===KING && p && p.kind===MAN){
    playSound('king');
  } else {
    playSound('move');
  }

  // limpar displayBoard e reavaliar turno/estado
  displayBoard = null;
  animating = false;

  // alternar turno e checar estados como antes
  turn = -turn;

  // empate por jogadas sem captura
  if(movesWithoutCapture >= MOVES_WITHOUT_CAPTURE_LIMIT){
    draw();
    setStatus("ü§ù Empate por regra de jogadas sem captura.");
    isThinking = false;
    setControlsEnabled(true);
    return;
  }

  if(!hasAnyMove(board, turn)){
    draw();
    const winner = -turn;
    if(winner===humanColor){ setStatus("‚úÖ Voc√™ venceu!"); playSound('win'); }
    else if(winner===aiColor){ setStatus("ü§ñ O computador venceu."); playSound('lose'); }
    else { setStatus("ü§ù Empate!"); }
    isThinking = false;
    setControlsEnabled(true);
    return;
  }

  computeLegal();
  draw();

  if(turn===aiColor){
    setStatus("Computador pensando‚Ä¶");
    aiThinkAndMove();
  }else{
    setStatus("Sua vez. " + (legalMoves.some(m=>m.isCapture) ? "Captura obrigat√≥ria dispon√≠vel!" : "Selecione uma pe√ßa."));
  }
}

function animateSegment(from, to, piece, move, segmentIndex){
  return new Promise(resolve=>{
    playSound('move'); // som leve no in√≠cio do deslocamento
    const pad = 12;
    const w = canvas.width, h = canvas.height;
    const ox = Math.floor((w - cell*SIZE)/2);
    const oy = Math.floor((h - cell*SIZE)/2);
    const fromX = ox + from[1]*cell + cell/2;
    const fromY = oy + from[0]*cell + cell/2;
    const toX = ox + to[1]*cell + cell/2;
    const toY = oy + to[0]*cell + cell/2;

    const duration = 220; // ms por segmento (pode ajustar)
    const start = performance.now();

    function frame(now){
      const t = Math.min(1, (now - start) / duration);
      const ease = t < 0.5 ? 2*t*t : -1 + (4 - 2*t)*t; // easing out/in
      const curX = fromX + (toX - fromX) * ease;
      const curY = fromY + (toY - fromY) * ease;

      draw(); // desenha o board atual (usa displayBoard enquanto presente)

      // desenhar pe√ßa em movimento por cima
      const color = piece.side===DARK ? getVar('--black') : getVar('--red');
      drawPiece(curX, curY, cell*0.38, color, 'rgba(0,0,0,0.55)');
      if(piece.kind===KING) drawCrown(curX,curY,cell*0.18);

      if(t < 1){
        requestAnimationFrame(frame);
      } else {
        // ao terminar o segmento, se houver captura nesse segmento, removemos
        if(move.captures && move.captures[segmentIndex]){
          const [cr,cc] = move.captures[segmentIndex];
          displayBoard[cr][cc] = EMPTY;
        }
        // mover pe√ßa tempor√°ria para posi√ß√£o final deste segmento no display
        displayBoard[to[0]][to[1]] = piece;
        resolve();
      }
    }
    requestAnimationFrame(frame);
  });
}

/* ---------- playMove atualizado para usar anima√ß√£o ---------- */
function playMove(move, fromHuman){
  if(!move) return;
  // bloqueia intera√ß√µes enquanto anima
  setControlsEnabled(false);
  animateAndApplyMove(move, fromHuman).finally(()=> {
    setControlsEnabled(true);
  });
}

/* ---------- UI helpers ---------- */
function setStatus(msg){ statusEl.textContent = msg; }
function setControlsEnabled(enabled){
  selDifficulty.disabled = !enabled;
  selHumanColor.disabled = !enabled;
  btnNew.disabled = !enabled;
}

/* ---------- Entrada (mouse/touch) ---------- */
canvas.addEventListener('pointerdown', e=>{
  canvas.setPointerCapture(e.pointerId);
  const pos = eventToBoard(e);
  if(!pos) return;
  onSquareTap(pos.r, pos.c);
});

function onSquareTap(r,c){
  if(turn!==humanColor || isThinking || animating) return;
  if(!legalMoves.length) return;

  const movesFromThis = legalMoves.filter(m=>m.from[0]===r && m.from[1]===c);
  const hasFrom = movesFromThis.length>0;

  if(selected){
    const [sr,sc] = selected;
    const cand = legalMoves.filter(m=>m.from[0]===sr && m.from[1]===sc)
      .find(m => {
        const end = m.path[m.path.length-1];
        return end[0]===r && end[1]===c;
      });
    if(cand){
      selected=null;
      playMove(cand, true);
      return;
    }
  }

  if(hasFrom){
    selected = [r,c];
    setStatus(legalMoves.some(m=>m.isCapture) ? "Captura obrigat√≥ria dispon√≠vel ‚Äì escolha o destino." : "Escolha o destino.");
    draw();
    return;
  }

  selected = null;
  draw();
}

/* converte evento para coordenadas do tabuleiro considerando dpr */
function eventToBoard(e){
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (canvas.width/rect.width);
  const y = (e.clientY - rect.top) * (canvas.height/rect.height);

  const w = canvas.width, h = canvas.height;
  const pad = 12;
  const cellLocal = Math.floor((Math.min(w,h) - pad*2)/SIZE);
  const ox = Math.floor((w - cellLocal*SIZE)/2);
  const oy = Math.floor((h - cellLocal*SIZE)/2);

  const c = Math.floor((x - ox)/cellLocal);
  const r = Math.floor((y - oy)/cellLocal);
  if(!within(r,c)) return null;
  const inX = (x>=ox && x<ox+cellLocal*SIZE);
  const inY = (y>=oy && y<oy+cellLocal*SIZE);
  if(!inX || !inY) return null;
  return {r,c};
}

/* ---------- Layout / DPI ---------- */
function resizeCanvas(){
  const box = canvas.parentElement.getBoundingClientRect();
  const size = Math.floor(Math.min(box.width, box.height));
  const dpr = Math.min(2, window.devicePixelRatio || 1);
  canvas.width = Math.floor(size * dpr);
  canvas.height = Math.floor(size * dpr);
  canvas.style.width = `${size}px`;
  canvas.style.height = `${size}px`;
  draw();
}
window.addEventListener('resize', resizeCanvas);
window.addEventListener('orientationchange', ()=>setTimeout(resizeCanvas, 200));

/* ---------- Acessibilidade: teclado (setas + Enter + Esc) ---------- */
canvas.addEventListener('keydown', e=>{
  if(turn!==humanColor || isThinking || animating) {
    if(e.key === 'Escape'){ selected = null; draw(); }
    return;
  }

  const moves = legalMoves;
  if(!moves.length) return;

  if(!selected){
    if(hints.length) selected = hints[0].slice();
    else selected = moves[0].from.slice();
    draw();
    return;
  }

  const [sr, sc] = selected;
  let nr = sr, nc = sc;
  if(e.key === 'ArrowUp') nr = Math.max(0, sr-1);
  else if(e.key === 'ArrowDown') nr = Math.min(SIZE-1, sr+1);
  else if(e.key === 'ArrowLeft') nc = Math.max(0, sc-1);
  else if(e.key === 'ArrowRight') nc = Math.min(SIZE-1, sc+1);
  else if(e.key === 'Enter'){
    const movesFromThis = legalMoves.filter(m => m.from[0]===sr && m.from[1]===sc);
    if(movesFromThis.length === 1){
      playMove(movesFromThis[0], true);
      selected = null;
      draw();
      return;
    }
    const cand = movesFromThis[0];
    if(cand){ playMove(cand, true); selected = null; draw(); }
    return;
  }else if(e.key === 'Escape'){
    selected = null; draw(); return;
  } else {
    selected = [nr,nc]; draw(); return;
  }
  selected = [nr,nc];
  draw();
});

/* ---------- UI / listeners ---------- */
btnNew.addEventListener('click', ()=>{
  startGame();
  resizeCanvas();
  canvas.focus();
});

selHumanColor.addEventListener('change', ()=>{
  startGame();
  resizeCanvas();
  canvas.focus();
});

selDifficulty.addEventListener('change', ()=>{
  setStatus("Dificuldade: " + selDifficulty.selectedOptions[0].text);
});

function updateLegend(){
  const human = selHumanColor.value === 'BLACK' ? 'BLACK' : 'RED';
  if(human === 'BLACK'){
    legendBlack.innerHTML = '<i class="dot black"></i>Preto <span class="you">(Voc√™)</span>';
    legendRed.innerHTML = '<i class="dot red"></i>Vermelho';
  }else{
    legendBlack.innerHTML = '<i class="dot black"></i>Preto';
    legendRed.innerHTML = '<i class="dot red"></i>Vermelho <span class="you">(Voc√™)</span>';
  }
}

/* ---------- Boot ---------- */
startGame();
resizeCanvas();
canvas.setAttribute('role', 'application');
canvas.focus();

</script>
</body>
</html>
